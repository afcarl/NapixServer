.. currentmodule:: napixd.managers.base

.. highlight:: python

=========================
Managers and sub-managers
=========================

The resources retrieved by the managers can contain an array or a dict of values.
But when this dict or list grows up, or its generation is expensive,
it may be useful do delegate its management to another manager.

Setup
=====

This demonstration will use the password files module written in the :ref:`first step guide<first_step>`.
We will manage several files with the same manager.

Let's assume we have a shared hosting server, and each customer has a folder inside :file:`/var/http/virtualhosts/`.
This folder is protected by a password in :file:`.htaccess`.

The user can enable and disable the protection of his folder, and set the protection name.
The user can also set the logins and the passwords in another file in :file:`/var/http/passwords`

The :file:`/var/http/` looks like::

    /var/http/
    |-- virtualhosts/
    |   +-- client1/
    |   |   |-- file
    |   |   +-- .htaccess
    |   +-- client2/
    |       +-- .htaccess
    +-- passwords/
        |-- client1
        +-- client2

Both managers are in :download:`/samples/protecteddir.py`.

HTAccessManager
---------------

The htaccess manager takes care of the :file:`.htaccess` file found inside of the protected directory.
It looks like this::

    AuthType Basic
    AuthName *authname*
    AuthUserFile /var/http/passwords/*name*
    *if enabled* Require valid-user

The fields are `enabled`, a boolean that tell if the protection is enforced,
`authname` which is a message to the user trying to authenticate.

You can see in the code that a key ``authuserfile`` key is added to the resources dict.
This key won't be exported to the users who make a GET request,
but it will be passed to the managed resources spawned.

.. literalinclude:: /samples/protecteddir.py
    :language: python
    :lines: 11-97


PasswordsManager
----------------

We will use the :class:`BasicPasswordFileManager` of the first step guide with a very few modifications.
The validations and resources_fields will be kept, but we will add several lines in save and load.

We replace ``self.FILEPATH`` by ``parent['authuserfile']``.
``parent`` is the resource generated by the :class:`HTAccessManager` and
authuserfile is the field that was not exported.

The rest of the file is untouched


.. literalinclude:: /samples/protecteddir.py
    :lines: 99-170

Plug
====

To plug :class:`PasswordsManager` as a sub-manager of :class:`HTAccessManager`,
you just need to add it to the :attr:`Manager.managed_class`.
You can add the class object or the class name as a string.

.. code-block:: python

    managed_class = ['PasswordsManager']

.. note::

    Those two lines are almost equivalent.
    In order to use the second, you have to declare the class :class:`PasswordsManager`
    before the class :class:`HTAccessManager`
    else it will raise a :exc:`NameError`

    .. code-block:: python

        managed_class = ['PasswordsManager']
        managed_class = [PasswordsManager]

    If PasswordsManager in another module, those two structures are almost equivalent to the previous.
    The behavior is not the same if ``another.module`` fails to import.

    .. code-block:: python

        managed_class = ['another.module.PasswordsManager']

        from another.module import PasswordsManager
        managed_class = [PasswordsManager]

Usage
=====

This is used like a normal manager::

    $ mkdir -p /var/http/{virtualhosts/client,passwords}
    $ napix
    >> get /htaccess/
    [
        /htaccess/client
    ]
    >> get /htaccess/client
    {
        authname =
        enabled = false
    }
    >> post /htaccess/ authname="enter your password" enabled=1
    {
        authname = enter your password
        enabled = true
    }
    >> get /htaccess/client/
    [
        "/htaccess/client/passwords"
    ]
    >> get /htaccess/client/passwords/
    []

    >> post /htaccess/client/passwords/ username=jason password=bourne09
    {
        password = bourne09
        username = jason
    }

    $ cat /var/http/virtualhosts/client/.htaccess
    AuthUserFile /var/http/passwords/client
    AuthType Basic
    AuthName enter your password
    Require valid-user

    $ cat /var/http/passwords/client
    jason:bourne09


Configuration of the link
=========================

.. currentmodule:: napixd.managers.managed_classes

When the link between the parent and the managed class must be set more precisely,
you can use the :class:`ManagedClass` class.

It defines two properties, the :meth:`name<ManagedClass.get_name>`
and the :meth:`~ManagedClass.extractor`.

:class:`ManagedClass` is usable with both the path
and manager class designation and both in direct and with a list
The :attr:`Manager.managed_class` list can contains :class:`ManagerClass` instances, strings and :class:`Manager` subclasses mixed.


name
----

The name is the bit of namespace between the two resources.

For example in order to set the url format to /htacces/``client``/htpasswd/``login``
without changing the name of the manager, the name argument of the :class:`ManagedClass`
can be used with inside class.

.. code-block:: python

    class HTAccessManager(Manager):
        """ Manages the protection of the directories of the users """

        VHOSTPATH = '/var/http/virtualhosts'
        PASSPATH = '/var/http/passwords'

        managed_class = [ManagedClass('PasswordsManager', name='htpasswd')]

With the :class:`ManagedClass` instance, the same rules applies
regarding the reference to the class.
You can either use a diret reference, or the name or the dotted path with the module.

extractor
---------

The extractor is a callback called with the parent and returning the arguments for the
instanciation of the Sub manager.

By default the extractor returns the parent.

The extractor use cases include the reuse of a same manager with different sources.
For examples the Central server of napix uses a same :class:`PermissionManager`
for public and users permissions.
An extractor in the *managed_class* of the :class:`UserManager` returns
the permissions of the users.
A root manager :class:`PublicPermissionsManager` inheriting of :class:`PermissionManager`
instanciates it with the public permissions set ad context.

Other uses includes the url permissions, for example, if you want to create groups of resources.
For example, in :mod:`django` inspired code:

.. code-block:: python

    class RouterManager(Manager):
        """Manager for the routers"""

    class ByNetwork(Manager):
        managed_class = [
            ManagedClass(RouterManager, extractor=lambda r: Router.objects.filter(network=r.id)),
            ]

    class ByBrand(Manager):
        managed_class = [
            ManagedClass(RouterManager, extractor=lambda r: Router.objects.filter(brand=r.id)),
            ]

Thus you can set permissions to all the Cisco routers for Cisco professionals: ``/bybrand/cisco/router/*``
and by network for the admins of a specific subnet: ``/bynetwork/10.23.0.0-24/router/*``.


Instanciate Managers
====================

Dont do it.
