#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
This module provides some classes to implements default strategies
for managers.

They will load all the resources of the manager, allow the user to make
requests and persist all the objects after.
"""

import os

from threading import Lock
from time import time

from napixd.exceptions import NotFound, Duplicate, ValidationError
from napixd.managers import Manager


class ReadOnlyDictManager(Manager):
    """
    Manager that manages a list (or a dict) of objects

    Once it's created, it manage a internal list of resources.
    This list of resources is generated by the method :meth:`load`
    that MUST be overriden.
    It is saved in the manager and used to serve the basic operations

    The list of resources MUST be an indexable object.
    The id of the resources MUST be the index of the resource
    in the internal list.

    This manager give only access to resources by read-only GET requests.


    .. attribute:: resources

        A mapping of the loaded resources.
        This is lazily evaluated.
    """

    # Methods to override
    def load(self, context):
        """
        Load: Return the list of the resources managed by this manager
        take the context that created this manager instance as argument
        """
        raise NotImplementedError('load')

    def _get_resources(self):
        if hasattr(self, '_resources'):
            return self._resources

        resources = self.load(self.context)
        try:
            self._resources = dict(resources)
        except TypeError:
            raise ValueError('load did not return a dict, but {0}',
                             type(resources).__name__)
        return self._resources

    def _set_resources(self, value):
        self._resources = value
    # resources are lazy loaded
    resources = property(_get_resources, _set_resources)

    def get_resource(self, resource_id):
        try:
            return self.resources[resource_id]
        except KeyError:
            raise NotFound(resource_id)

    def list_resource(self):
        return self.resources.keys()


class DictManager(ReadOnlyDictManager):
    """
    Manager for a dictionary of resources.

    This manager inherits of the read-only version
    and add support for modifications
    When the resources list is modified, the method :meth:`save`
    is called to persist the resources

    The id of a new resource is generated by the method :meth:`generate_new_id`.
    """

    def __init__(self, context):
        super(DictManager, self).__init__(context)
        # lock to avoid race conditions
        self.resource_lock = Lock()

    def save(self, context, resources):
        """
        Save the resources after they have been altered by the user's request.
        Idempotent methods (GET, HEAD) don't trigger :meth:`save`
        """
        raise NotImplementedError('save')

    def generate_new_id(self, resource_dict):
        """
        Generate a new identifier for the resource dict given
        It must be overriden by the sub classes
        """
        raise NotImplementedError('generate_new_id')

    # private methods and attributes

    def end_request(self, request):
        """
        overrides the context's method to save the resources after every request
        that may have altered the datas
        """
        if request.method not in ('GET', 'HEAD'):
            self.save(self.context, self.resources)

    def _set_resource(self, resource_id, resource_dict):
        """
        Set a resource inside the resources list
        """
        self.resources[resource_id] = resource_dict

    def modify_resource(self, resource, resource_dict):
        with self.resource_lock:
            resource.resource.update(resource_dict)
            self._set_resource(resource.id, resource.resource)

    def create_resource(self, resource_dict):
        with self.resource_lock:
            resource_id = self.generate_new_id(resource_dict)
            if resource_id in self.resources:
                raise Duplicate(resource_id)
            self._set_resource(resource_id, resource_dict)
            return resource_id

    def delete_resource(self, resource):
        with self.resource_lock:
            try:
                del self.resources[resource.id]
            except KeyError:
                raise NotFound(resource.id)


class ListManager(DictManager):
    """
    Manager that manages a list of resources
    """

    def create_resource(self, resource_dict):
        with self.resource_lock:
            self.resources.append(resource_dict)
            return len(self.resources) - 1

    def list_resource(self):
        return range(0, len(self.resources))

    def validate_id(self):
        """
        Override the base method to limit id to integer values
        """
        try:
            return int(self)
        except (ValueError, TypeError):
            raise ValidationError('This resource ids are integers')


class FileManager(DictManager):
    """
    Manager that is attached to a file
    """

    def __init__(self, context):
        super(FileManager, self).__init__(context)
        self.last_read = None

    def is_up_to_date(self):
        """
        Return True if the file was written over since we last read/wrote it.
        """
        if self.last_read is None:
            return False
        filename = self.get_filename(self.context)
        last_write = os.path.getmtime(filename)
        return self.last_read >= last_write

    def load(self, context):
        """
        Opens the file for reading, gives it to :meth:`parser`
        so that it extracs the data
        """
        filename = self.get_filename(context)
        try:
            handle = open(filename, 'r')
        except IOError:
            return {}

        self.last_read = time()
        with handle as fp:
            return dict(self.parse(fp))

    def save(self, context, resources):
        """
        Opens the file and then gives it to :meth:`write`
        """
        filename = self.get_filename(context)
        with open(filename, 'w') as fp:
            self.write(fp, resources)
            self.last_read = time()

    def get_filename(self, context):
        """
        Get the filename from the context
        """
        raise NotImplementedError('get_filename')

    def parse(self, fp):
        """
        Extract the datas from the file stream given
        """
        raise NotImplementedError('parse')

    def write(self, fp, resources):
        """
        Write the content to the file stream given
        """
        raise NotImplementedError('write')
