#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""

Default Managers
================


This module provides some classes to implements default strategies for managers.

They will load all the resources of the manager, allow the user to make requests
and persist all the objects after.
"""

import os

from threading import Lock
from time import time

from napixd.exceptions import NotFound, Duplicate, ValidationError
from napixd.managers import Manager

class ReadOnlyDictManager(Manager):
    """
    Manager that manages a list (or a dict) of objects

    Once it's created, it manage a internal list of resources.
    This list of resources is generated by the method `load` that MUST be overriden.
    It is saved in the manager and used to serve the basic operations

    The list of resources MUST be an indexable object.
    The id of the resources MUST be the index of the resource in the internal list.

    This manager give only access to resources in for GET request
    """

    #Methods to override
    def load(self,parent):
        """
        Load: Return the list of the resources managed by this manager
        take the parent that created this manager instance as argument

        example:

        >>>class CountryManager(ListManager):
        >>>     def load(self,parent):
        >>>         f=open('/'+parent['galaxy']+'/'+parent['planet'],'r')
        >>>         countries = []
        >>>         for x in f.readline():
        >>>             countries.append(x)
        >>>         return x

        GET /worlds/earth/france
        >>>parent = WorldManager().get_resource('earth')
        >>>parent
        World { 'name':'planet', 'galaxy': 'Milky Way'}
        >>>earth_countries = CountryManager(parent)
        >>>earth_countries.get_resource('france')
           earth_countries.load({'name':'earth','galaxy':'Milky Way'})

        """
        raise NotImplementedError, 'load'

    def _get_resources(self):
        if hasattr(self, '_resources'):
            return self._resources

        resources = self.load(self.parent)
        try:
            self._resources = dict(resources)
        except TypeError:
            raise ValueError('load did not return a dict, but {0}',
                             type(resources).__name__)
        return self._resources

    def _set_resources(self,value):
        self._resources = value
    #resources are lazy loaded
    resources = property(_get_resources,_set_resources)

    def get_resource(self,resource_id):
        try:
            return self.resources[resource_id]
        except KeyError:
            raise NotFound,resource_id

    def list_resource(self):
        return self.resources.keys()

class DictManager(ReadOnlyDictManager):
    """
    Manager for a dictionary of resources.

    This manager inherits of the read-only version and add support for modifications
    When the resources list is modified, the method `save` is called to persist the resources

    The id of a new resource is generated by the method `generate_new_id`.
    """

    def __init__(self,parent):
        super(DictManager,self).__init__(parent)
        #lock to avoid race conditions
        self.resource_lock = Lock()

    def save(self,parent,content):
        """
        Save the ressources after they have been altered by the user's request.
        Idempotent methods (GET,HEAD) don't trigger the save

        >>>class CountryManager(ListManager):
        >>>     def save(self,parent,ressources):
        >>>         f=open('/'+parent['galaxy']+'/'+parent['planet'],'w')
        >>>         countries = []
        >>>         for x in resources:
        >>>             countries.write(x)
        >>>             countries.write('\n')

        """
        raise NotImplementedError, 'save'

    def generate_new_id(self,resource_dict):
        """
        Generate a new identifier for the resource dict given
        It must be overriden by the sub classes
        """
        raise NotImplementedError, 'generate_new_id'

    #private methods and attributes


    def end_request(self,request):
        """
        overrides the parent's method to save the ressources after every request
        that may have altered the datas
        """
        if request.method not in ('GET','HEAD'):
            self.save(self.parent,self.resources)


    def _set_resource(self,resource_id,resource_dict):
        """
        Set a resource inside the resources list
        """
        self.resources[resource_id] = resource_dict


    def modify_resource(self,resource_id,resource_dict):
        with self.resource_lock:
            resource = self.get_resource(resource_id)
            resource.update(resource_dict)
            self._set_resource(resource_id,resource)

    def create_resource(self,resource_dict):
        with self.resource_lock:
            resource_id = self.generate_new_id(resource_dict)
            if resource_id in self.resources:
                raise Duplicate, resource_id
            self._set_resource(resource_id,resource_dict)
            return resource_id

    def delete_resource(self,resource_id):
        with self.resource_lock:
            try:
                del self.resources[resource_id]
            except KeyError:
                raise NotFound, resource_id

class ListManager(DictManager):
    """
    Manager that manages a list of resources
    """
    def create_resource(self,resource_dict):
        with self.resource_lock:
            self.resources.append(resource_dict)
            return len(self.resources) - 1

    def list_resource(self):
        return range(0,len(self.resources))

    def validate_id(self):
        """
        Override the base method to limit id to integer values
        """
        try:
            return int(self)
        except  (ValueError,TypeError):
            raise ValidationError('This resource ids are integers')


class FileManager(DictManager):
    """
    Manager that is attached to a file
    """
    def __init__(self,parent):
        super(FileManager,self).__init__(parent)
        self.last_read = None

    def is_up_to_date(self):
        """
        Return True if the file was written over since we last read/wrote it.
        """
        if self.last_read is None:
            return False
        filename = self.get_filename(self.parent)
        last_write = os.path.getmtime(filename)
        return self.last_read >= last_write

    def load(self,parent):
        """
        Opens the file for reading, gives it to :meth:`parser`
        so that it extracs the data
        """
        filename = self.get_filename(parent)
        try:
            handle = open(filename,'r')
        except IOError:
            return {}

        self.last_read = time()
        with handle as fp:
            return dict( self.parse(fp))

    def save(self,parent,resources):
        """
        Opens the file and then gives it to :meth:`write`
        """
        filename = self.get_filename(parent)
        with open(filename,'w') as fp:
            self.write(fp,resources)
            self.last_read = time()

    def get_filename(self,parent):
        """
        Get the filename from the parent
        """
        raise NotImplementedError, 'get_filename'

    def parse(self,fp):
        """
        Extract the datas from the file stream given
        """
        raise NotImplementedError, 'parse'

    def write(self,fp,resources):
        """
        Write the content to the file stream given
        """
        raise NotImplementedError, 'write'


