
.. py:module:: managers


Manager
=======

The Manager class is the base class for all managers.

Manager :
    - manages a set of resources
    - does it by defining create/delete/modify methods that act on those resources
Ressource :
    - MUST be a dict (or an emulation thereof) that hold a set of properties
    - They MAY have actions

Manager are created by the corresponding resource

.. py:class:: Manager

    Base class of the managers

    Managers are objects created to serve requests on a resource for its sub resources
    example:

    .. code-block :: none

        GET /physics/constants/c

    A manager is created of the resource *physics*, this resource is asked for its child *constants*,
    a manager for this resource *constant* is created, and this manager is asked for its child *c*.
    The resource got is serialized and sent back to the user

    Managers cycle of life MAY contains multiple request, that MAY be executed simultaneously.

    The cycle of life is :

    - Class creation
    - Insertion into the application inside the root manager or through a parent manager
    - Manager.configure is called with the settings of this class
    - An instance is generated for a resource
       * start_request is called
       * the appropriate method to respond to the request is called (get_resource, create_resource, etc)
       * end_request is called

    Subclasses MAY set a :py:attr:`managed_class` class attribute.
    If set, it must be either a class inheriting from this same base class
    (or implementing its interface) or a iterable of those classes.

    If it's a single class, the resources are wrapper in this class when going up a level in the URL.
    When going up of a level in the url, children are wrapped in this class

    examples:

    .. code-block:: python

        class FirstManager(Manager):
            managed_class = SecondManager

        class SecondManager(Manager):
            def list_resource(self):
                return {}

        #GET /first/second/third
        second_resource = FirstManager().get_resource('second') #/first
        second_manager = SecondManager(second_resource)  # [..]/second
        return second_manager.get_resource('third')  # [..]/third

    If it's a tuple or a list of classes, the children have multiple subressource managers attached.
    The class in wich the children is wrapped depends on the url path
    example

    .. code-block:: python

        class Main(Manager):
             managed_class = [ManagerA,ManagerB]
        class ManagerA(Manager):
             pass
        class ManagerB(Manager):
             pass

        #GET /main/1
        Main().get_resource(1)

        #GET /main/1/
        [ 'A', 'B' ]

        #GET /main/1/A/
        ManagerA(Main().get_resource(1)).list_resource()

        #GET /main/1/B/
        ManagerB(Main().get_resource(1)).list_resource()

        #GET /main/1/B/3
        ManagerB(Main().get_resource(1)).get_resource(3)

    If it's not set, the manager does not have sub resources

    .. code-block:: none

        #GET /first/second/third/
        404 NOT FOUND

        #GET /first/second/third/fourth
        404 NOT FOUND

    The resources may contains some fields that are not in the class' resource_fields.
    When the resource are serialized to be send in json,
    only the fields in resource_fields are extracted.

    This behavior may be usefull to pass privates values to the next managers.
    exemple

    .. code-block :: python

            class SectionManager(Manager):
                """
                Manages each of the section of a configuration file
                """
                def list_resource(self):
                    return self.parent['parser'].get_sections()

            class File(Manager):
                """
                Manages a list of configuration files inside /etc
                """
                 managed_class = SectionManager
                 resource_fields = {
                    'path': {
                        'description' : 'file path'
                        }
                    }
                 def get_resource(self,id):
                     return {'parser':Parser('/etc/'+id),'path':'/etc'+id}

            GET /file/file1
            { "path" : "/etc/file1" }
            #No parser field sent

            GET /file/file1/
            [ "section1" , "section2"]
            #Parser was passed to list_resource through parent

    .. py:attribute:: managed_class

        Class wraping the children

    .. py:method:: __init__( parent )

        intialize the Manager with the parent resource creating it

        .. code-block:: python

            class FirstManager(Manager):
                 managed_class = SecondManager

            class SecondManager(Manager):
                 def list_resource(self):
                     return {}

            #GET /first/second/
            SecondManager(FirstManager.get_resource('second')).list_resource()


    .. py:classmethod::  detect() -> Boolean

        Auto detection function.
        This function is called by napixd to check if the manager is needed,
        when it is loaded by autodetection.

        .. code-block:: python

            import platform

            @classmethod
            def detect(cls):
                #Activate the manager only if the host is Linux
                return platform.platform() == 'Linux'

    .. py:classmethod::  configure(conf)

        Method called with the configuration of this class

    .. py:method::  is_up_to_date()

        Method to check if the data contained are fresh.
        If it's not the manager is recreated

    .. py:method::  start_request(request)

        place holder method that is called at the start of each HTTP request

    .. py:method::  end_request(request)

        place holder method that is called at the end of each HTTP request

Auto documentation
------------------

.. py:class:: Manager

    .. py:classmethod::  get_name() -> name

        Returns the name of the manager.
        By default it's the class name.

    .. py:method::  get_example_resource() -> resource_dict

        Generate an example of the resources managed by this manager
        Computed by the *example* of each resource field in :py:attr:`resource_fields`


    .. py:attribute:: resource_fields

        List of the fields publicly available with their properties

        Subclasses of this class MUST define their own list of fields
        in the class attribute resource_fields.

        This attribute is a dict where the keys are the fields names and the values are
        the descriptions of those fields

        Properties includes:

            * optional : if the value is optional
            * example : used for documentation and the example resource
            * description : describe the use of the resource
            * computed : This field is computed by the service and the user CAN NOT force it

        example:

        .. code-block :: python

            class User(Manager):
                resource_fields = {
                    'username':{'description':'POSIX username of the system account', 'example':'dritchie'},
                    'uid':{'description':'Unique identifier, will be generated if not given','optional':True},
                    'gecos':{'description':'Comment on the user name',example:'Dennis M. Ritchie'}
                    }

.. _validation:

Validation
----------

.. py:class:: Manager

    The validation methods of the Manager class take the proposed user input and either return the correct value even if unchanged
    or raise a :py:exc:`ValidationError`.

    It may change the type of the variable,
    for example to convert number to strings to integer values,
    to query integer indexed values in a list.


    .. py:method::  validate_id(id) -> id

        Check that the id given as an argument is a valid ID

        The id is always a string extracted from the url.

        If the id is not valid, raises a :py:exc:`ValidationError`.
        If necessary, modify the id
        this method MUST return the ID even if it wasn't modified.

        This method shoud not check if the id correspond to an existing value.
        It shoud just verify that the id does not contains anything that can harm the next methods,
        `delete_resource`, `get_resource` or `modify_resource`.
        Else, it could lead to 400 errors instead of 404 errors.

        example:

        If the id must be an int

        .. code-block:: python

             class IntID(Manager):
                 def validate_id(self,id_):
                     try:
                         return int(id_)
                     except ValueError:
                         raise ValidationError

        If the id must be a string containing at least 3 charcters

        .. code-block:: python

            class MinLength(Manager):
                 def validate_id(self,id_):
                     if len(id_) < 3:
                         raise ValidationError
                     #always return the id
                     return id_

        By default, this method checks if the id is not an empty string

    .. py:method::  validate_resource_FIELDNAME( value )

        If a Manager defines a field `x` and a method `validate_resource_x`,
        this method will be used to validate this field.

        Like :py:meth:`validate_id`, it must return the correct value, even if it was not changed
        or throw a :py:exc:`ValidationError` if the value is incorrect.


    .. py:method::  validate_resource( resource_dict) -> resource_dict

        Validate a resource_dict (which can be directly a dict or an object emulating a dict) by
        checking that every mandatory field specified in self.resource_fields is defined.

        If the current object implement self.validate_resource_**key** method, it'll be called with
        the value of resource_dict[**key**] as parameter.

        It shoud raise a :py:exc:`ValidationError` if the data isn't valid, else it must return a valid value


Collection and resources methods
--------------------------------

.. py:class:: Manager

    The :py:class:`Manager` class does not implements any of these.

    The Manager subclasses *MAY* implement all or only a part of the methods below.

    The not implemented methods will be answered by a 405 METHOD NOT ALLOWED response
    with the list of the authorized methods computed from to the existing methods.

    If a Manager subclass implements a method or define an attribute with one of those names,
    the corresponding feature will be considered being implemented.

    The manager MUST NOT define a method with a raise NotImplementedError
    to mean that the method is not supported.


    All the **resource_id** and **resource_dict** given to the following methods have been cleaned with
    :py:meth:`validate_id` and :py:meth:`validate_resource` respectively.


    .. py:method::  delete_resource(resource_id)

        Delete a managed ressource.

        .. code-block:: python

            #DELETE /something/[...]/mymanager/42
            mymanager.delete_resource('42')

    .. py:method::  create_resource( resource_dict) -> id

        Create a new managed ressource.

        resource_dict is a dict populated with the data sent by the user after they have been cleaned.

        This method MUST return the id of the resource created

        .. code-block:: python

            #POST /something/[...]/mymanager/ with resource_dict { 'toto': 1 }
            mymanager.create_resource({ 'toto': 1})


    .. py:method::  get_resource(resource_id) -> resource_dict

        Get the ressource object corresponding to resource_id.

        This object must be a dict or emulate it, as the nAPIxd will convert this dict
        to a json object to build his response.

        .. code-block:: python

            #GET /somehting/[...]/mymanager/42
            mymanager.get_resource(self, '42')


    .. py:method::  modify_resource(resource_id,resource_dict)

        Modify the ressource designed by resource_id by updating it with resource_dict
        defined values.

        If modify_resource is not defined, it's emulated by calling delete/create sequentially.

        .. code-block:: python

            #PUT /something/[...]/mymanager/42
            mymanager.modify_resource('42', { 'toto': 4242 })


    .. py:method::  list_resource() -> list

        Return the ids list of all managed resource. The result can be of 2 form : either a direct list
        of string, representing each id, or a list of dict, defining at least '_id' and '_desc' as key.

        .. code-block:: python

            #GET /something/[...]/mymanager/
            mymanager.list_resource_id()

        After processing, the Napix daemon will always convert the list in a list of dict, and add
        the _uri key with appropriate value (based on baseurl + _id).

